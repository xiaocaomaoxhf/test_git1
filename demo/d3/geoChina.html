<!DOCTYPE HTML><html lang="en"><head>  <meta charset="UTF-8">  <title>Hello D3</title>  <script src="d3.js"></script>  <style>  </style></head><body><script>d3.json('geoChina.json', function(error, data) {    if (error) {        return console.error(error);    }    //获得地图的中心    function getCenters(features) {        var longitudeMin = 100000;        var latitudeMin = 100000;        var longitudeMax = 0;        var latitudeMax = 0;        features.forEach(function(e) {            var a = d3.geo.bounds(e);            if (a[0][0] < longitudeMin) {                longitudeMin = a[0][0];            }            if (a[0][1] < latitudeMin) {                latitudeMin = a[0][1];            }            if (a[1][0] > longitudeMax) {                longitudeMax = a[1][0];            }            if (a[1][1] > latitudeMax) {                latitudeMax = a[1][1];            }        });        var a = (longitudeMax + longitudeMin) / 2;        var b = (latitudeMax + latitudeMin) / 2;        return [a, b];    }    //设置地图的大小    function getZoomScale(features, width, height) {        var longitudeMin = 100000;        var latitudeMin = 100000;        var longitudeMax = 0;        var latitudeMax = 0;        features.forEach(function(e) {            var a = d3.geo.bounds(e);            if (a[0][0] < longitudeMin) {                longitudeMin = a[0][0];            }            if (a[0][1] < latitudeMin) {                latitudeMin = a[0][1];            }            if (a[1][0] > longitudeMax) {                longitudeMax = a[1][0];            }            if (a[1][1] > latitudeMax) {                latitudeMax = a[1][1];            }        });        var a = longitudeMax - longitudeMin;        var b = latitudeMax - latitudeMin;        return Math.min(width / a, height / b);    }    var width = 1000;    var height = 800;    var projection = d3.geo.mercator()        .center(getCenters(data.features))        .scale(getZoomScale(data.features, width, height) * 50)        .translate([width / 2, height / 2]);    var path = d3.geo.path()        .projection(projection);    var color = d3.scale.category20();    var bounds = path.bounds(data);    var topleft = bounds[0];    var bottomright = bounds[1];    // console.log(path.bounds(data))    // console.log(path.centroid(data))    // console.log(path.area(data))    var svg = d3.select('body').append('svg').attr({        width: width,        height: height        // width: bottomright[0]-topleft[0],        // height: bottomright[1]-topleft[1]    })    svg.selectAll("path")        .data(data.features)        .enter()        .append("path")        .attr("stroke", "#000")        .attr("stroke-width", 1)        .attr("fill", function(d, i) {            return color(i);        })        .attr("d", path) //使用地理路径生成器        .on("mouseover", function(d, i) {            d3.select(this)                .attr("fill", "yellow");        })        .on("mouseout", function(d, i) {            d3.select(this)                .attr("fill", color(i));        });})</script></body>